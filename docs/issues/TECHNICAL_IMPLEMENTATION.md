# é€šä¹‰å¬æ‚ŸASR POCæŠ€æœ¯å®ç°è¯¦è§£

## ğŸ—ï¸ æ•´ä½“æ¶æ„è®¾è®¡

### ç³»ç»Ÿæ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        é€šä¹‰å¬æ‚Ÿè¯­éŸ³è½¬å†™ç³»ç»Ÿ                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ç”¨æˆ·å±‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  éŸ³é¢‘æ–‡ä»¶è¾“å…¥   â”‚  â”‚  è½¬å†™ç»“æœæŸ¥çœ‹   â”‚  â”‚  æ–‡ç¨¿æå–å·¥å…·   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  åº”ç”¨å±‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ TingwuClient    â”‚  â”‚  OSSUploader    â”‚  â”‚ ExtractTool     â”‚ â”‚
â”‚  â”‚ (æ ¸å¿ƒæ§åˆ¶å™¨)    â”‚  â”‚  (æ–‡ä»¶ä¸Šä¼ )     â”‚  â”‚ (ç»“æœè§£æ)      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æœåŠ¡å±‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  é˜¿é‡Œäº‘OSS      â”‚  â”‚  é€šä¹‰å¬æ‚ŸAPI    â”‚  â”‚  HTTPå®¢æˆ·ç«¯     â”‚ â”‚
â”‚  â”‚  (æ–‡ä»¶å­˜å‚¨)     â”‚  â”‚  (è¯­éŸ³è½¬å†™)     â”‚  â”‚  (ç»“æœä¸‹è½½)     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ•°æ®æµå‘
```
éŸ³é¢‘æ–‡ä»¶ â†’ OSSä¸Šä¼  â†’ é€šä¹‰å¬æ‚ŸAPI â†’ çŠ¶æ€ç›‘æ§ â†’ ç»“æœä¸‹è½½ â†’ æ–‡ç¨¿æå–
    â†“         â†“          â†“          â†“          â†“          â†“
  æœ¬åœ°æ–‡ä»¶   å…¬å¼€URL    ä»»åŠ¡åˆ›å»º    è½®è¯¢çŠ¶æ€   JSONæ•°æ®   æ ¼å¼åŒ–æ–‡æœ¬
```

## ğŸ”§ æ ¸å¿ƒæ¨¡å—å®ç°

### 1. é…ç½®ç®¡ç†æ¨¡å— (`config.py`)

```python
class Config:
    """é…ç½®ç®¡ç†ç±» - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰é…ç½®é¡¹"""
    
    # ä»ç¯å¢ƒå˜é‡è¯»å–é…ç½®
    ACCESS_KEY_ID = os.getenv('ALIBABA_CLOUD_ACCESS_KEY_ID')
    ACCESS_KEY_SECRET = os.getenv('ALIBABA_CLOUD_ACCESS_KEY_SECRET')
    TINGWU_APPKEY = os.getenv('ALIBABA_TINWU_APPKEY')
    
    @classmethod
    def validate(cls):
        """éªŒè¯å¿…è¦çš„é…ç½®é¡¹æ˜¯å¦å­˜åœ¨"""
        required_configs = [
            ('ACCESS_KEY_ID', cls.ACCESS_KEY_ID),
            ('ACCESS_KEY_SECRET', cls.ACCESS_KEY_SECRET),
            ('TINGWU_APPKEY', cls.TINGWU_APPKEY)
        ]
        
        for name, value in required_configs:
            if not value:
                raise ValueError(f"Missing required config: {name}")
```

**è®¾è®¡è¦ç‚¹**ï¼š
- é›†ä¸­ç®¡ç†æ‰€æœ‰é…ç½®é¡¹
- ç¯å¢ƒå˜é‡ä¼˜å…ˆï¼Œæ”¯æŒé»˜è®¤å€¼
- å¯åŠ¨æ—¶éªŒè¯å¿…è¦é…ç½®
- æ”¯æŒä¸åŒç¯å¢ƒçš„é…ç½®åˆ‡æ¢

### 2. OSSæ–‡ä»¶ä¸Šä¼ æ¨¡å— (`oss_uploader.py`)

```python
class OSSUploader:
    """OSSæ–‡ä»¶ä¸Šä¼ å™¨ - å¤„ç†éŸ³é¢‘æ–‡ä»¶ä¸Šä¼ åˆ°é˜¿é‡Œäº‘OSS"""
    
    def __init__(self):
        """åˆå§‹åŒ–OSSå®¢æˆ·ç«¯å’Œé…ç½®"""
        self.auth = oss2.Auth(access_key_id, access_key_secret)
        self.bucket_name = "tingwu-audio-poc"
        self.endpoint = f"https://oss-{region}.aliyuncs.com"
        
    def ensure_bucket_exists(self) -> bool:
        """ç¡®ä¿bucketå­˜åœ¨ï¼Œä¸å­˜åœ¨åˆ™åˆ›å»º"""
        try:
            self.bucket = oss2.Bucket(self.auth, self.endpoint, self.bucket_name)
            self.bucket.get_bucket_info()  # æ£€æŸ¥bucketæ˜¯å¦å­˜åœ¨
            return True
        except oss2.exceptions.NoSuchBucket:
            # åˆ›å»ºbucketå¹¶è®¾ç½®å…¬å…±è¯»å–æƒé™
            self.bucket.create_bucket(oss2.BUCKET_ACL_PUBLIC_READ)
            return True
    
    def upload_file(self, local_file_path: str) -> dict:
        """ä¸Šä¼ æ–‡ä»¶åˆ°OSSå¹¶è¿”å›å…¬å¼€URL"""
        # 1. ç”Ÿæˆå”¯ä¸€çš„å¯¹è±¡é”®å
        timestamp = int(time.time())
        filename = os.path.basename(local_file_path)
        object_key = f"audio/{timestamp}_{filename}"
        
        # 2. ä¸Šä¼ æ–‡ä»¶å¹¶è®¾ç½®å…¬å…±è¯»å–æƒé™
        result = self.bucket.put_object_from_file(
            object_key, 
            local_file_path,
            headers={'x-oss-object-acl': 'public-read'}
        )
        
        # 3. æ„å»ºå…¬å¼€è®¿é—®URL
        file_url = f"https://{self.bucket_name}.oss-{self.region}.aliyuncs.com/{object_key}"
        
        return {
            'success': True,
            'file_url': file_url,
            'object_key': object_key,
            'etag': result.etag
        }
```

**å…³é”®æŠ€æœ¯ç‚¹**ï¼š
- **è‡ªåŠ¨bucketç®¡ç†**: æ£€æŸ¥å¹¶åˆ›å»ºbucket
- **å…¬å…±è¯»å–æƒé™**: ç¡®ä¿é€šä¹‰å¬æ‚Ÿèƒ½è®¿é—®æ–‡ä»¶
- **å”¯ä¸€æ–‡ä»¶å**: ä½¿ç”¨æ—¶é—´æˆ³é¿å…å†²çª
- **é”™è¯¯å¤„ç†**: å®Œå–„çš„å¼‚å¸¸å¤„ç†æœºåˆ¶

### 3. é€šä¹‰å¬æ‚Ÿå®¢æˆ·ç«¯ (`tingwu_client.py`)

#### 3.1 æ ¸å¿ƒæ§åˆ¶å™¨

```python
class TingwuClient:
    """é€šä¹‰å¬æ‚Ÿå®¢æˆ·ç«¯ - æ ¸å¿ƒä¸šåŠ¡é€»è¾‘æ§åˆ¶å™¨"""
    
    def __init__(self):
        """åˆå§‹åŒ–é˜¿é‡Œäº‘SDKå®¢æˆ·ç«¯"""
        credentials = AccessKeyCredential(access_key_id, access_key_secret)
        self.client = AcsClient(region_id=region, credential=credentials)
        
    def transcribe_audio(self, audio_file_path: str) -> dict:
        """ä¸»è¦ä¸šåŠ¡æµç¨‹ - éŸ³é¢‘è½¬å†™å®Œæ•´æµç¨‹"""
        # 1. éŸ³é¢‘æ–‡ä»¶åˆ†æ
        audio_info = self.analyze_audio_file(audio_file_path)
        
        # 2. å°è¯•çœŸå®APIè½¬å†™
        real_result = self.try_real_transcription(audio_file_path)
        
        # 3. å¤„ç†ç»“æœå¹¶è¿”å›
        return self.process_transcription_result(real_result, audio_info)
```

#### 3.2 éŸ³é¢‘æ–‡ä»¶åˆ†æ

```python
def analyze_audio_file(self, audio_file_path: str) -> dict:
    """åˆ†æéŸ³é¢‘æ–‡ä»¶è·å–åŸºæœ¬ä¿¡æ¯"""
    with wave.open(audio_file_path, 'rb') as wav_file:
        frames = wav_file.getnframes()
        sample_rate = wav_file.getframerate()
        channels = wav_file.getnchannels()
        sample_width = wav_file.getsampwidth()
        duration = frames / sample_rate
        
        return {
            'duration': duration,
            'sample_rate': sample_rate,
            'channels': channels,
            'sample_width': sample_width
        }
```

#### 3.3 è½¬å†™ä»»åŠ¡åˆ›å»º

```python
def create_transcription_task(self, file_url: str, audio_info: dict) -> dict:
    """åˆ›å»ºé€šä¹‰å¬æ‚Ÿè½¬å†™ä»»åŠ¡"""
    # æ„å»ºè¯·æ±‚ä½“
    body = {
        'AppKey': Config.TINGWU_APPKEY,
        'Input': {
            'FileUrl': file_url,
            'Format': 'wav',
            'SampleRate': audio_info['sample_rate'],
            'SourceLanguage': 'cn'
        }
    }
    
    # åˆ›å»ºé€šç”¨è¯·æ±‚
    request = self.create_common_request(
        domain=Config.ENDPOINT,
        version='2023-09-30',
        protocol_type='https',
        method='PUT',
        uri='/openapi/tingwu/v2/tasks'
    )
    
    # æ·»åŠ æŸ¥è¯¢å‚æ•°å’Œè¯·æ±‚ä½“
    request.add_query_param('type', 'offline')
    request.set_content(json.dumps(body).encode('utf-8'))
    
    # å‘é€è¯·æ±‚
    response = self.client.do_action_with_exception(request)
    return json.loads(response)
```

#### 3.4 ä»»åŠ¡çŠ¶æ€ç›‘æ§

```python
def wait_for_completion(self, task_id: str, max_wait_time: int = 300) -> dict:
    """ç­‰å¾…ä»»åŠ¡å®Œæˆ - è½®è¯¢ç›‘æ§æœºåˆ¶"""
    start_time = time.time()
    check_interval = 10  # æ¯10ç§’æ£€æŸ¥ä¸€æ¬¡
    
    while time.time() - start_time < max_wait_time:
        # æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€
        result = self.get_task_result(task_id)
        
        if not result['success']:
            return result
        
        status = result['response']['Data']['TaskStatus']
        
        if status in ['SUCCESS', 'COMPLETED']:
            # ä»»åŠ¡å®Œæˆï¼Œå¤„ç†ç»“æœ
            return self.handle_completed_task(result)
        elif status == 'FAILED':
            # ä»»åŠ¡å¤±è´¥
            return self.handle_failed_task(result)
        elif status in ['ONGOING', 'PENDING', 'QUEUEING']:
            # ä»»åŠ¡è¿›è¡Œä¸­ï¼Œç»§ç»­ç­‰å¾…
            time.sleep(check_interval)
        else:
            # æœªçŸ¥çŠ¶æ€ï¼Œè®°å½•å¹¶ç»§ç»­ç­‰å¾…
            print(f"Unknown status: {status}")
            time.sleep(check_interval)
    
    # è¶…æ—¶å¤„ç†
    return {'success': False, 'error': 'Timeout waiting for completion'}
```

#### 3.5 ä»»åŠ¡ç»“æœæŸ¥è¯¢

```python
def get_task_result(self, task_id: str) -> dict:
    """æŸ¥è¯¢ä»»åŠ¡ç»“æœ - æŒ‰ç…§å®˜æ–¹APIè§„èŒƒ"""
    try:
        # æ„å»ºæŸ¥è¯¢URI - å°†TaskIdæ”¾åœ¨è·¯å¾„ä¸­
        uri = f'/openapi/tingwu/v2/tasks/{task_id}'
        
        request = self.create_common_request(
            domain=Config.ENDPOINT,
            version='2023-09-30',
            protocol_type='https',
            method='GET',
            uri=uri
        )
        
        response = self.client.do_action_with_exception(request)
        response_data = json.loads(response)
        
        return {
            'success': True,
            'task_id': task_id,
            'response': response_data
        }
    except Exception as e:
        return {
            'success': False,
            'error': str(e),
            'error_type': type(e).__name__
        }
```

#### 3.6 è½¬å†™ç»“æœä¸‹è½½

```python
def download_transcription_result(self, transcription_url: str) -> dict:
    """ä¸‹è½½è½¬å†™ç»“æœæ–‡ä»¶"""
    try:
        response = requests.get(transcription_url, timeout=30)
        response.raise_for_status()
        
        # è§£æJSONç»“æœ
        result_data = response.json()
        
        return {
            'success': True,
            'data': result_data
        }
    except Exception as e:
        return {
            'success': False,
            'error': str(e)
        }
```

### 4. æ–‡ç¨¿æå–å·¥å…· (`extract_transcript.py`)

```python
def extract_full_transcript(result_file: str) -> str:
    """ä»è½¬å†™ç»“æœä¸­æå–å®Œæ•´æ–‡ç¨¿"""
    
    # 1. è¯»å–å¹¶è§£æJSONç»“æœ
    with open(result_file, 'r', encoding='utf-8') as f:
        data = json.load(f)
    
    raw_transcription = data['result']['raw_transcription']
    transcription = raw_transcription['Transcription']
    
    # 2. è§£ææ®µè½å’Œå•è¯æ•°æ®
    paragraphs = transcription['Paragraphs']
    sentence_details = []
    
    for para_idx, paragraph in enumerate(paragraphs, 1):
        speaker_id = paragraph.get('SpeakerId', 'æœªçŸ¥')
        words = paragraph.get('Words', [])
        
        # æŒ‰å¥å­åˆ†ç»„
        sentences = {}
        for word in words:
            sentence_id = word.get('SentenceId', 1)
            if sentence_id not in sentences:
                sentences[sentence_id] = []
            sentences[sentence_id].append(word)
        
        # æ„å»ºå¥å­æ–‡æœ¬å’Œæ—¶é—´æˆ³
        for sentence_id in sorted(sentences.keys()):
            sentence_words = sentences[sentence_id]
            sentence_text = "".join([w.get('Text', '') for w in sentence_words])
            
            if sentence_text.strip():
                start_time = min([w.get('Start', 0) for w in sentence_words]) / 1000
                end_time = max([w.get('End', 0) for w in sentence_words]) / 1000
                
                sentence_details.append({
                    'paragraph': para_idx,
                    'sentence': sentence_id,
                    'speaker': speaker_id,
                    'start': start_time,
                    'end': end_time,
                    'text': sentence_text.strip()
                })
    
    # 3. ç”Ÿæˆæ ¼å¼åŒ–è¾“å‡º
    detailed_transcript = []
    detailed_transcript.append("å®Œæ•´è½¬å†™æ–‡ç¨¿ï¼ˆå¸¦æ—¶é—´æˆ³ï¼‰")
    detailed_transcript.append("=" * 60)
    
    for detail in sentence_details:
        time_str = f"[{detail['start']:.1f}s-{detail['end']:.1f}s]"
        speaker_str = f"è¯´è¯äºº{detail['speaker']}" if detail['speaker'] != '1' else ""
        text_line = f"{time_str} {speaker_str} {detail['text']}"
        detailed_transcript.append(text_line.strip())
    
    # 4. ç”Ÿæˆçº¯æ–‡æœ¬ç‰ˆæœ¬
    full_text = "\n\n".join([detail['text'] for detail in sentence_details])
    detailed_transcript.append("\n" + "=" * 60)
    detailed_transcript.append("çº¯æ–‡æœ¬ç‰ˆæœ¬")
    detailed_transcript.append("=" * 60)
    detailed_transcript.append(full_text)
    
    return "\n".join(detailed_transcript)
```

## ğŸ”„ å…³é”®ä¸šåŠ¡æµç¨‹

### 1. å®Œæ•´è½¬å†™æµç¨‹

```mermaid
sequenceDiagram
    participant User as ç”¨æˆ·
    participant Client as TingwuClient
    participant OSS as OSSä¸Šä¼ å™¨
    participant API as é€šä¹‰å¬æ‚ŸAPI
    participant Download as ç»“æœä¸‹è½½
    
    User->>Client: æäº¤éŸ³é¢‘æ–‡ä»¶
    Client->>Client: åˆ†æéŸ³é¢‘ä¿¡æ¯
    Client->>OSS: ä¸Šä¼ æ–‡ä»¶åˆ°OSS
    OSS-->>Client: è¿”å›å…¬å¼€URL
    Client->>API: åˆ›å»ºè½¬å†™ä»»åŠ¡
    API-->>Client: è¿”å›TaskId
    
    loop çŠ¶æ€ç›‘æ§
        Client->>API: æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€
        API-->>Client: è¿”å›çŠ¶æ€ä¿¡æ¯
        alt ä»»åŠ¡å®Œæˆ
            Client->>Download: ä¸‹è½½è½¬å†™ç»“æœ
            Download-->>Client: è¿”å›JSONæ•°æ®
        else ä»»åŠ¡è¿›è¡Œä¸­
            Client->>Client: ç­‰å¾…10ç§’
        end
    end
    
    Client-->>User: è¿”å›è½¬å†™ç»“æœ
```

### 2. é”™è¯¯å¤„ç†æµç¨‹

```mermaid
flowchart TD
    A[å¼€å§‹è½¬å†™] --> B{OSSä¸Šä¼ }
    B -->|æˆåŠŸ| C{åˆ›å»ºä»»åŠ¡}
    B -->|å¤±è´¥| D[è¿”å›ä¸Šä¼ é”™è¯¯]
    
    C -->|æˆåŠŸ| E{çŠ¶æ€ç›‘æ§}
    C -->|å¤±è´¥| F[è¿”å›APIé”™è¯¯]
    
    E -->|COMPLETED| G{ä¸‹è½½ç»“æœ}
    E -->|FAILED| H[è¿”å›ä»»åŠ¡å¤±è´¥]
    E -->|ONGOING| I[ç­‰å¾…é‡è¯•]
    I --> E
    
    G -->|æˆåŠŸ| J[è¿”å›è½¬å†™ç»“æœ]
    G -->|å¤±è´¥| K[è¿”å›ä¸‹è½½é”™è¯¯]
```

## ğŸ›¡ï¸ é”™è¯¯å¤„ç†ç­–ç•¥

### 1. åˆ†å±‚é”™è¯¯å¤„ç†

```python
# ç½‘ç»œå±‚é”™è¯¯
try:
    response = self.client.do_action_with_exception(request)
except ClientException as e:
    return {'success': False, 'error': f'Client error: {e}'}
except ServerException as e:
    return {'success': False, 'error': f'Server error: {e}'}

# ä¸šåŠ¡å±‚é”™è¯¯
if response_data.get('Code') != '0':
    return {'success': False, 'error': response_data.get('Message')}

# æ•°æ®å±‚é”™è¯¯
try:
    result_data = response.json()
except json.JSONDecodeError as e:
    return {'success': False, 'error': f'Invalid JSON response: {e}'}
```

### 2. é‡è¯•æœºåˆ¶

```python
def retry_with_backoff(func, max_retries=3, base_delay=1):
    """æŒ‡æ•°é€€é¿é‡è¯•æœºåˆ¶"""
    for attempt in range(max_retries):
        try:
            return func()
        except Exception as e:
            if attempt == max_retries - 1:
                raise e
            delay = base_delay * (2 ** attempt)
            time.sleep(delay)
```

### 3. çŠ¶æ€æ¢å¤

```python
def handle_task_failure(self, task_result):
    """å¤„ç†ä»»åŠ¡å¤±è´¥æƒ…å†µ"""
    error_code = task_result.get('ErrorCode')
    error_message = task_result.get('ErrorMessage')
    
    # æ ¹æ®é”™è¯¯ç±»å‹å†³å®šæ˜¯å¦é‡è¯•
    if error_code in ['TSC.FileError']:
        # æ–‡ä»¶é”™è¯¯ï¼Œä¸é‡è¯•
        return {'success': False, 'error': 'File access error', 'retry': False}
    elif error_code in ['TSC.InternalError']:
        # å†…éƒ¨é”™è¯¯ï¼Œå¯é‡è¯•
        return {'success': False, 'error': 'Internal error', 'retry': True}
    else:
        # æœªçŸ¥é”™è¯¯ï¼Œè®°å½•å¹¶ä¸é‡è¯•
        return {'success': False, 'error': f'Unknown error: {error_message}', 'retry': False}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å¼‚æ­¥å¤„ç†

```python
import asyncio
import aiohttp

async def async_transcribe_batch(self, audio_files):
    """æ‰¹é‡å¼‚æ­¥è½¬å†™"""
    tasks = []
    for audio_file in audio_files:
        task = asyncio.create_task(self.async_transcribe_single(audio_file))
        tasks.append(task)
    
    results = await asyncio.gather(*tasks, return_exceptions=True)
    return results
```

### 2. ç»“æœç¼“å­˜

```python
import hashlib
import pickle

def cache_result(self, audio_file_path, result):
    """ç¼“å­˜è½¬å†™ç»“æœ"""
    # ç”Ÿæˆæ–‡ä»¶å“ˆå¸Œä½œä¸ºç¼“å­˜é”®
    with open(audio_file_path, 'rb') as f:
        file_hash = hashlib.md5(f.read()).hexdigest()
    
    cache_file = f"cache/{file_hash}.pkl"
    with open(cache_file, 'wb') as f:
        pickle.dump(result, f)

def get_cached_result(self, audio_file_path):
    """è·å–ç¼“å­˜çš„è½¬å†™ç»“æœ"""
    with open(audio_file_path, 'rb') as f:
        file_hash = hashlib.md5(f.read()).hexdigest()
    
    cache_file = f"cache/{file_hash}.pkl"
    if os.path.exists(cache_file):
        with open(cache_file, 'rb') as f:
            return pickle.load(f)
    return None
```

### 3. è¿æ¥æ± ç®¡ç†

```python
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

def create_http_session():
    """åˆ›å»ºå¸¦è¿æ¥æ± çš„HTTPä¼šè¯"""
    session = requests.Session()
    
    # é…ç½®é‡è¯•ç­–ç•¥
    retry_strategy = Retry(
        total=3,
        backoff_factor=1,
        status_forcelist=[429, 500, 502, 503, 504]
    )
    
    # é…ç½®è¿æ¥æ± 
    adapter = HTTPAdapter(
        pool_connections=10,
        pool_maxsize=20,
        max_retries=retry_strategy
    )
    
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    
    return session
```

## ğŸ”’ å®‰å…¨è€ƒè™‘

### 1. å‡­è¯ç®¡ç†

```python
# ä½¿ç”¨ç¯å¢ƒå˜é‡å­˜å‚¨æ•æ„Ÿä¿¡æ¯
ACCESS_KEY_ID = os.getenv('ALIBABA_CLOUD_ACCESS_KEY_ID')
ACCESS_KEY_SECRET = os.getenv('ALIBABA_CLOUD_ACCESS_KEY_SECRET')

# é¿å…åœ¨æ—¥å¿—ä¸­è¾“å‡ºæ•æ„Ÿä¿¡æ¯
def safe_log(message, sensitive_data=None):
    if sensitive_data:
        # åªæ˜¾ç¤ºå‰4ä½å’Œå4ä½
        masked = sensitive_data[:4] + '*' * (len(sensitive_data) - 8) + sensitive_data[-4:]
        message = message.replace(sensitive_data, masked)
    print(message)
```

### 2. æ–‡ä»¶æƒé™æ§åˆ¶

```python
def upload_with_limited_access(self, file_path):
    """ä¸Šä¼ æ–‡ä»¶å¹¶è®¾ç½®æœ‰é™çš„è®¿é—®æƒé™"""
    # è®¾ç½®æ–‡ä»¶è¿‡æœŸæ—¶é—´
    expiration = datetime.utcnow() + timedelta(hours=24)
    
    # ä¸Šä¼ æ—¶è®¾ç½®è®¿é—®æ§åˆ¶
    result = self.bucket.put_object_from_file(
        object_key,
        file_path,
        headers={
            'x-oss-object-acl': 'public-read',
            'x-oss-expires': expiration.strftime('%a, %d %b %Y %H:%M:%S GMT')
        }
    )
```

### 3. è¾“å…¥éªŒè¯

```python
def validate_audio_file(self, file_path):
    """éªŒè¯éŸ³é¢‘æ–‡ä»¶çš„å®‰å…¨æ€§"""
    # æ£€æŸ¥æ–‡ä»¶å¤§å°
    file_size = os.path.getsize(file_path)
    if file_size > 100 * 1024 * 1024:  # 100MBé™åˆ¶
        raise ValueError("File too large")
    
    # æ£€æŸ¥æ–‡ä»¶æ ¼å¼
    allowed_extensions = ['.wav', '.mp3', '.m4a', '.flac']
    file_ext = os.path.splitext(file_path)[1].lower()
    if file_ext not in allowed_extensions:
        raise ValueError(f"Unsupported file format: {file_ext}")
    
    # æ£€æŸ¥æ–‡ä»¶å¤´
    with open(file_path, 'rb') as f:
        header = f.read(12)
        if not (header.startswith(b'RIFF') or header.startswith(b'ID3')):
            raise ValueError("Invalid audio file format")
```

## ğŸ“ˆ ç›‘æ§å’Œæ—¥å¿—

### 1. ç»“æ„åŒ–æ—¥å¿—

```python
import logging
import json

def setup_logging():
    """è®¾ç½®ç»“æ„åŒ–æ—¥å¿—"""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler('tingwu.log'),
            logging.StreamHandler()
        ]
    )

def log_transcription_event(self, event_type, task_id, details=None):
    """è®°å½•è½¬å†™äº‹ä»¶"""
    log_data = {
        'event_type': event_type,
        'task_id': task_id,
        'timestamp': datetime.utcnow().isoformat(),
        'details': details or {}
    }
    
    logging.info(json.dumps(log_data, ensure_ascii=False))
```

### 2. æ€§èƒ½ç›‘æ§

```python
import time
from functools import wraps

def monitor_performance(func):
    """æ€§èƒ½ç›‘æ§è£…é¥°å™¨"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        try:
            result = func(*args, **kwargs)
            success = True
        except Exception as e:
            result = None
            success = False
            raise
        finally:
            end_time = time.time()
            duration = end_time - start_time
            
            # è®°å½•æ€§èƒ½æŒ‡æ ‡
            log_performance_metric(
                function_name=func.__name__,
                duration=duration,
                success=success
            )
        
        return result
    return wrapper
```

### 3. å¥åº·æ£€æŸ¥

```python
def health_check(self):
    """ç³»ç»Ÿå¥åº·æ£€æŸ¥"""
    checks = {
        'oss_connection': self.check_oss_connection(),
        'tingwu_api': self.check_tingwu_api(),
        'disk_space': self.check_disk_space(),
        'memory_usage': self.check_memory_usage()
    }
    
    all_healthy = all(checks.values())
    
    return {
        'healthy': all_healthy,
        'checks': checks,
        'timestamp': datetime.utcnow().isoformat()
    }
```

## ğŸš€ éƒ¨ç½²å’Œæ‰©å±•

### 1. DockeråŒ–éƒ¨ç½²

```dockerfile
FROM python:3.12-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY src/ ./src/
COPY examples/ ./examples/

ENV PYTHONPATH=/app/src

CMD ["python", "src/tingwu_client.py"]
```

### 2. å¾®æœåŠ¡æ¶æ„

```python
from flask import Flask, request, jsonify
from celery import Celery

app = Flask(__name__)
celery = Celery('tingwu_service')

@app.route('/transcribe', methods=['POST'])
def transcribe_endpoint():
    """è½¬å†™æœåŠ¡APIç«¯ç‚¹"""
    file = request.files['audio']
    
    # å¼‚æ­¥å¤„ç†
    task = transcribe_task.delay(file.filename)
    
    return jsonify({
        'task_id': task.id,
        'status': 'processing'
    })

@celery.task
def transcribe_task(file_path):
    """å¼‚æ­¥è½¬å†™ä»»åŠ¡"""
    client = TingwuClient()
    result = client.transcribe_audio(file_path)
    return result
```

### 3. æ°´å¹³æ‰©å±•

```python
class TingwuCluster:
    """é€šä¹‰å¬æ‚Ÿé›†ç¾¤ç®¡ç†"""
    
    def __init__(self, nodes):
        self.nodes = nodes
        self.current_node = 0
    
    def get_next_node(self):
        """è´Ÿè½½å‡è¡¡ - è½®è¯¢ç®—æ³•"""
        node = self.nodes[self.current_node]
        self.current_node = (self.current_node + 1) % len(self.nodes)
        return node
    
    def transcribe_with_failover(self, audio_file):
        """å¸¦æ•…éšœè½¬ç§»çš„è½¬å†™"""
        for node in self.nodes:
            try:
                return node.transcribe_audio(audio_file)
            except Exception as e:
                logging.warning(f"Node {node} failed: {e}")
                continue
        
        raise Exception("All nodes failed")
```

---

**ğŸ“ æ€»ç»“**: æœ¬æŠ€æœ¯å®ç°æ–‡æ¡£è¯¦ç»†æè¿°äº†é€šä¹‰å¬æ‚ŸPOCçš„å®Œæ•´æŠ€æœ¯æ¶æ„ã€æ ¸å¿ƒæ¨¡å—å®ç°ã€å…³é”®ä¸šåŠ¡æµç¨‹ã€é”™è¯¯å¤„ç†ç­–ç•¥ã€æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆã€å®‰å…¨è€ƒè™‘ã€ç›‘æ§æ—¥å¿—ä»¥åŠéƒ¨ç½²æ‰©å±•æ–¹æ¡ˆï¼Œä¸ºç”Ÿäº§ç¯å¢ƒé›†æˆæä¾›äº†å®Œæ•´çš„æŠ€æœ¯å‚è€ƒã€‚